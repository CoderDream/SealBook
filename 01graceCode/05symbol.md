# 【优雅代码】05-异或、左移、右移到底该怎么用
> 欢迎关注b站账号/公众号【六边形战士夏宁】，一个要把各项指标拉满的男人。该文章已在[github目录](https://github.com/edanlx/SealBook)收录。
屏幕前的**大帅比**和**大漂亮**如果有帮助到你的话请顺手点个赞、加个收藏这对我真的很重要。别下次一定了，都不关注上哪下次一定。
* [gitee目录](https://gitee.com/seal_li/SealBook)
* [知乎目录](https://zhuanlan.zhihu.com/p/338222208)
* [csdn目录](https://blog.csdn.net/seal_li/article/details/111415366)
* [博客园目录](https://www.cnblogs.com/sealLee/articles/14748368.html)
* [上一篇](./04thread.md)1行代码完成多线程
* [下一篇](./06apacheUtils.md)apache下的优秀工具类

## 1.算数运算符
### 1.1.单目
* 负号运算符(-):就是负数
* 自增(++):++i表示先自己加1再赋值
* 自减(--):--i表示先自己先减1再赋值
### 1.2.双目
在A,B,n>0时,B为2^n可以使用其他操作符，但不要为了用而用，让代码变得难懂，除非做底层，否在不建议业务代码使用
* 加(+):四则运算加
* 减(-):四则运算减
* 乘(*):可用A << n,四则运算乘
* 除(/):A >> n,四则运算除
* 取余(%):A&(B-1)---->这个在源码里面比较常见比如hash
### 1.3.三目
* a>b?true:false
## 2.关系运算符
* 等于符号(==):等于
* 不等于符号(!=):不等于
* 大于符号(>):大于
* 小于符号(<):小于
* 大于等于符号(>=):大于等于
* 小于等于符号(<=):小于等于
## 3.位与逻辑
### 3.1.位运算符
* 或(|):逐位比较两个操作数中只要有1个为1，结果为1，否则结果为0,得出最终结果
  示例如下：x=(x<<1)|y其中x为位运算压缩空间的数值，左移一位方便将y值压入，因为只移了一位所以y只能为1或0，即x左移位数应于y的位数一致。此时因为y值前面都是0所以均取x原先值，到了y值得位置时反过来此时x该位置都补了0所以都取y的值，以此形成状态压缩
* 与(&):逐位比较两个操作数,两位同时为1，结果才为1，否则结果为0,得出最终结果。通常会用于高位清零的操作-> a&1  = 0 偶数
    x&(x-1)=0
* 非(~):逐位自己的运算符，0则为1，1则为0,得出最终结果。
    ~x=-x-1
* 异或(^):逐位比较两个操作数，相同即为0，不同则为1。以动态规划算法，可以迅速判断是否仅仅是进行了交换，或者从偶数项里面找到唯一的奇数项等
    (1)x^x=0
    (2)x^y=y^x(交换律)
    (3)(x^y)^z=x^(y^z)(结合律)
    (4)x^y^y=x(自反性)->异或0就等于自己
    (5)4k^(4k+1)^(4k+2)^(4k+3)=0
    <!--(6)当a为4k时,b为4k+1,4k+2或者4k+3时满足a^b = |a-b|-->
* 二进制状态压缩
|操作|运算|
|--|--|
|取出 n 的第 k 位|( n >> k ) & 1|
|取出 n 的后 k 位（ 0 ~ k-1 位）|  n& ( ( 1 << k ) - 1 )|
|将第 k 位变为 1，赋值到 n  |  n|= ( 1 << k )  |
|将第 k 位变为 0，赋值到 n  |  n&= ( ~ ( 1 << k ) )  |

### 3.2.逻辑运算符
* 与(&&):数学上的交集
* 非(!):取反
* 或(||):数学上的并集
## 4.赋值
* 等于(=):将运算结果或者内存地址给到符号引用
* 加等于(+=)、减等于(-=)、乘等于(*=)、除等于(/=)、取余等于(%=):基本无应用场景、与等于(&=):基本无应用场景、异或等于(^=)、或等于(|=):基本无应用场景、左移等于(<<=):基本无应用场景、右移等于(>>=)
## 5.位移
* 带符号左移<<: x<<y 相当于x*(2^y)--->此处的^代表次方不是异或
* 带符号右移>>: x>>y 相当于x/(2^y)--->此处的^代表次方不是异或
* 无符号左移<<<
* 无符号右移>>>

## 6.延伸规则
1、a%2^{n}=a&(2^{n}-1)。即a与2的n次方的数取余，等于a与此值减一后的值按位取与。
2、a%2^{n}=x,则a%2^{n+1}=x,或者a%2^{n+1}=x+2^{n}。
3、a%2^{n}=x,如果a&2^{n}=0，则a%2^{n+1}=x否则a%2^{n+1}=x+2^{n}。

## 7.编者注
以上个人认为比较重要的有如下
1. 取余的变种按位与,即1.2的最后一个
2. 延伸规则，直接案例也是hashMap的高低位桶
3. 位移符，一些coder喜欢秀操作会经常用，参考用例还是hashMap的默认容量
4. 位运算符的常见规律，算法中会遇到
## 8.位的基础知识
正数的原码，补码，反码都是一样的  
负数的原码开头高为1其余一致，反码除开头不变其它取反，补码为反码的基础上加1  
计算为补码相加  

左移<<，左移1位则最左边的数丢弃，右边进一位0刚好是乘以2  
正数右移则为补0  
负数右移则为先转为补码高位补1，再得到源码  
