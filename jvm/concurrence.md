<center>偏向锁、轻量锁、重量锁到底是啥?</center>

# 一.友情链接
[目录](https://github.com/edanlx/SealBook/blob/master/catalog.md)  
[视频讲解](https://www.bilibili.com/video/BV1Sz4y1f7FB/)   
[文字版](https://github.com/edanlx/SealBook/blob/master/jvm/concurrence.md)

# 二.概述
多任务处理在现代计算机操作系统中几乎已是一项必备的功能了。在许多场景下，让计算机同时 去做几件事情，不仅是因为计算机的运算能力强大了，还有一个很重要的原因是计算机的运算速度与  它的存储和通信子系统的速度差距太大，大量的时间都花费在磁盘I/O、网络通信或者数据库访问上。这个在 [一行代码完成多线程](https://github.com/edanlx/SealBook/blob/master/graceCode/thread.md)有写过如何分配线程，原理基本一致。  
由于计算机 的存储设备与处理器的运算速度有着几个数量级的差距，所以现代计算机系统都不得不加入一层或多 层读写速度尽可能接近处理器运算速度的高速缓存(Cache)  来作为内存与处理器之间的缓冲，但同时引入新的问题即缓存一致性Java虚拟机的即时编译器中也有指令重排序 (Instruction Reorder)优化([详见](https://github.com/edanlx/SealBook/blob/master/jvm/compile.md))。
# 三.java内存模型
## 3.1主内存与工作内存
主内存直接对应于物理硬件的内存，而为了获取更好的运行速度，虚拟机(或者是硬件、操作系统本身的优化措施)可能会让工作内存优先存储于寄存器和高速缓存中，因为程序运行时主要访问的是工作内存。
## 3.2内存间交互操作
Java内存模型中定义了以下8种操作来完成:lock(锁定)\unlock(解锁)\read(从主内存读取到工作内存中)\load(放入工作内存副本)\use(载入执行引擎)\assign(赋值)\store(传递至主内存)\write(写入主内存)。即不允许read和load、store和write操作之一单独出现。对一个变量执行unlock操作之前，必须先把此变量同步回主内存中(执行store、write操作)等
## 3.3volatile
可以被认为是轻量级同步，仅保证可见性
## 3.4long和double型变量的特殊规则
## 3.5原子性、可见性与有序性
# 四.java与线程
## 4.1内核线程
## 4.2线程调度
## 4.3状态转换
# 五.java与协程
## 5.1用户线程
# 六.线程安全
## 6.1Java语言中的线程安全
### 6.1.1不可变
### 6.1.2绝对线程安全
### 6.1.3相对线程安全
### 6.1.4线程兼容
### 6.1.5线程对立
## 6.2线程安全的实现方法
### 6.2.1互斥同步
### 6.2.非阻塞同步
# 七.锁优化
## 7.1自旋锁与自适应自旋
## 7.2锁消除
## 7.3锁粗化
## 7.4轻量级锁
## 7.5偏向锁