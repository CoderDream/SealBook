《rocketmq技术内幕》
学习之前应该熟悉netty
1.阅读源代码前的准备
	1.3 RocketMQ 的设计理念和目标
		1.3.1设计理念
			因为 Topic 路由信息无须在集群之间保持强一致，追求最终一致性，并且能容忍分钟级的不一致 正是基于此种情况 RocketMQ NameServer 集群之间互不通信
		1.3.2 设计目标
			1. 架构模式
				发布订阅模式
			2. 顺序消患
				就是消息消费者按照消息达到消息存储服务器的顺序消费rocketMQ可以严格保证消息有序
			3. 消息过滤
				消息消费者可以对同一主题下的消息按照规 只消费自己感兴趣的消息,在brocker过滤则不传递给消费者
			4. 消息存储
				消息堆积能力和消息存储性能。RocketMQ 追求消息存储的高性能，引人内存映射机制，所有主题的消息顺序存储在同一个文件中 同时为了避免消息无限在消息存储服务器中累积，引入了消息文件过期机制与文件存储空间报警机制
			5. 消息高可用性
				通常影响消息可靠性的有以下几种情况
					1.Broker 正常关机
					2.Broker 异常 Crash
					3.OS Crash
					4.机器断电，但 能立即恢复供电情况
					5.机器无法开机
					6.硬件损坏
					1~4会在异步刷盘丢失少量信息
					5~6开启异步复制可以保证只丢失少量信息
			6.消息消费低延迟
				RocketMQ 在消息不发生消息堆积时，以长轮询模式实现准实时的消息推送模式
			7.确保消息必须被消费一次
				RocketMQ 通过消息消费确认机制（ACK）来确保消息至少被消费一次
			8. 回溯消息
				已经消费成功的消息需要再次消费
			9. 消息堆积
				必须应对数据洪峰。过期时间默认3天
			10. 定时消息
				到达Brocker不可被立即消费，到达指定时间才可以消费
			11. 消息重试机制
				消息重试是指消息在消费时，如果发送异常，消息中间件需要支持消息重新投递，RocketMQ 支持消息重试机制
2.rocketmq路由中心NameServer
	2.1 NameServer 架构设计
		消息消费者(Consumer）订阅感兴趣的主题，消息服务器根据订阅信息（路由信息）将消息推送到消费者（ PUSH 模式）或者消息消费者主动向消息服务器拉取消息（ PULL 模式），从而实现消息生产者与消息消费者解耦
	2.2 NameServer 启动流程
		Step1 首先来解析配置文件 需要填充NameServerConfig、NettyServerConfig属性值
		Step2 根据启动属性创建NamesrvController 实例，并初始化该实例 NameServerController
			开启两个定时任务，即心跳检测
			定时任务1: NameServer 每隔1Os 扫描一次 Broker 移除处于不激活状态的 Broker
			定时任务 2: nameserver 每隔 10 分钟打印一次 KV配置
		Step3 ：注册 JVM 钩子函数并启动服务器， 以便监昕 Broker、消息生产者的网络请求(jvm的shutdownHook，在tomcat中亦有使用)
	2.3 NameServer的路由注册、故障剔除
		NameServer主要作用是为消息生产者和消息消费者提供关于主题 Topic 的路由信息，那么 NameServer不仅要存储路由的基础信息，还要能够管理Broker节点，包括路由路由删除等功能
		2.3.1路由元信息

		2.3.2路由注册
		2.3.3路由删除
		2.3.4路由发现
3.rocketmq消息发送
4.rocketmq消息存储
5.rocketmq消息消费
6.消息过滤FilterServer
7.rocketmq主从同步
8.rocketmq事务消息
9.rocketmq实战