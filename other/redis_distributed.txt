redis进阶
4.1事务处理
watch命令，可以监控多个key，一旦某个被监控的值被修改，当前事务未执行的命令不会再执行
4.2过期时间
淘汰规则
|规则|说明|
|--|--|
|volatile-lru|使用LRU算法那删除一个键(只对设置了过期时间的)|
|allkeys-lru|使用LRU算法那删除一个键|
|volatils-random|随机删除一个键(只对设置了过期时间的)|
|allkeys-random|随机删除一个键|
|volatile-ttl|删除过期时间最近的一个键|
|noeviction|直接返回错误|
4.3排序
	4.3.2sort
	直接排序使用sort命令即可，可跟随desc命令
	4.3.3by命令
	依赖其它字段排序
	```
	redis>LPUSH sortbylist 2 1 3
	(integer)3
	redis>SET itemscore:1 50
	OK
	redis>SET itemscore:2 100
	OK
	redis>SET itemscore:3 -10
	OK
	redis>SORT sortbylist BY itemscore:* DESC
	1)2
	2)1
	3)3
	```
	4.3.4get命令
	假设列表 mylist包含元素1、 2 和 3，分别代表了存储在object_1、object_2 和 object_3中的对象的唯一ID。当这些对象关联到存储在weight_1、 weight_2 和 weight_3 中的权重
	SORT mylist BY weight_* GET object_*。此时返回的是object_1、object_2、object_3。这里mylist存储的元素必须与object_*、weight_*中的*对应
	4.3.5store参数
	可以将结果再存储
	4.3.6性能优化
	当排序的结果很大时，需要使用limit参数
4.4消息通知
6.脚本
	Redis在2.6版本推出了脚本功能,允许开发者使用Lua语言编写脚本传到Redis中执行。好处如下:
	1)减少网络开销，合并请求
	2)原子操作
	3)复用，会被保存到redis，其它语言也可以调用
7.持久化
	与基础版一致
8.集群
	8.1复制
		8.1.5从数据库持久化
			采用哨兵模式
		8.1.6无硬盘复制
			一般复制为RDB复制，为了解决RDB文件的网络开销。可以开启无硬盘复制，直接将命令进行发送与AOF类似
		8.1.7增量复制
			1)从数据库记录主数据库id
			2)每个向从数据库发送的命令会存入积压队列且有自己的偏移量
			3)从数据库每次同步完成会记录偏移量，如果相差过大(即积压队列中没有)则进行完全同步
	8.2哨兵
		8.2.3实现原理
		在一主多从的情况下，可以使用哨兵进行监控，使系统足够稳健。哨兵只需要配置主数据库，从数据库会自行读取，同时其会完成选举等操作。使用redis-sentinel /path/sentinel.conf进行启动。启动后会立即与主库建立连接，并定时执行下面3个操作
		1)每10秒会向主数据库、从数据库发送INFO命令
		2)每2秒向主、从数据库发送自己的信息
		3)每1秒向主从及其它哨兵发送ping命令
		当发现主数据库下线时采用Raft算法进行选举领头哨兵
		1)当前哨兵节点发送其它哨兵要求选自己
		2)如果目标哨兵没有投票其他人则投票给该节点
		3)如果超过半数则成为领头哨兵
		4)选举失败则重新发起
		挑选主数据库一般通过复制偏移量为准，条件一样则id小的优先
		8.2.4哨兵的部署
		一般每个节点都部署一个哨兵
	8.3集群
		8.3.1一个集群至少要3个节点
		8.3.2节点的增加
		8.3.3插槽的分配
			从16384个插槽进行均分。slot的有效部分为整个key如果有{}则以括弧内为准
		8.3.4获取与插槽对应的点
			如果该键不在该节点中则返回move命令重定向。客户端记录当前插槽是由哪个节点负责的。仅有16384个插槽
		8.3.5故障恢复
			集群中每个节点都会发送ping命令，相当于每个主节点都是哨兵。如果某个节点下线，则执行与哨兵模式一致的逻辑
9.管理
	9.2协议
		9.2.1简单协议
		9.2.2统一请求协议
			AOF复制等都是该协议
