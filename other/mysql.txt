高性能mysql笔记
第1章 mysql架构与历史
锁
	表锁，开销性能最小的锁粒度，在部分语句如alter table等语句(其会忽略存储引擎的锁机制)
	行级锁，InnoDBhe和XtraDB实现，其可以最大程度地支持并发
事务
	ACID:
		原子性(atomicity)-不可切割不能存在部分成功
		一致性(consistency)-从一个一致性状态转为另一个，即使系统崩溃也不存在中间态
		隔离性(isolation)-其它事务不可见
		持久性(durability)-系统崩溃数据也不会丢失
	隔离级别
		未提交读-会发生脏读问题
		提交读-处理脏读问题
		可重复读-处理可重复读问题(可重复读针对单条记录，幻读针对数量与范围。MVCC机制解决了幻读问题)
		可串行化-解决所有问题，但是效率低下
	死锁
		两个及以上的事务同时锁定同一个资源。
		事务1
			update 1 from dual where id = 1
			update 1 from dual where id = 2
		事务2
			update 2 from dual where id = 2
			update 3 from dual where id = 1
		如上情况，在执行第一句时，此时事务未发生冲突，在执行第二句时事务发生冲突，互相等待。传统做法为等待一段时间后放弃返回错误，但会引起慢查询。InnoDB在做法为回滚做少行数的事务。
	事务日志
		因为写日志是按顺序的要快很多，所以通常做法为在日志持久化后，再慢慢刷到实际数据库中，此方式被称之为预写式日志，修改数据要写两次磁盘
	InnoDB的显式锁
		select .... for update(非sql规范)
	InnoDB的MVCC
		不同数据库，不同存储引擎的MVCC实现不同，在这方面sql并没有统一规范，但实现思路均为保存某一时间的快照，根据事务开始的时间不同，快照数据可能是不一样的。
		在InnoDB中每行记录后还有行创建版本号、行删除版本号。每开始一个新的事务，系统版本号就会递增
		可重复读级别简易操作:
			selete
				InnoDB会根据一下两个条件检查每行记录:
				a.InnoDB只查找版本早于当前事务版本的数据行(也就是，行的系统版本号小于或等于事务的系统版本号)，这样可以确保实物读取的行，要么是在事务开始之前已经存在的，要么是事务自身插入或者修改过的。
				b.行的删除版本要么未定义，要么大于当前事务版本号。这可以确保实物读取到的行，在事务开始之前未被删除。
			insert
			 	InnoDB为新插入的每一行保存当前系统版本号作为行版本号
			delete
				InnoDB为删除的每一行保存当前系统版本号作为删除标识
			update
				InnoDB为插入一行新纪录，保存当前系统版本号作为行版本号,同时保存当前系统版本号到原来的行作为删除标识(注意新增和删除是两列版本号)
		InnoDB的MVCC只能解决部分幻读问题，如果某事务在当前事务之前开始则会存在问题,以复杂的修改为例,原数据的创建版本未发生变化，但因为多出来一条数据，如果创建版本小于当前事务则会被查询出来，而原数据因为select.b规则所以不会被查询出来
		【TODO】
存储引擎
	在文件系统中，mysql将每个数据库(schema)保存位数据目录下的一个子目录。创建表时，mysql会在数据库子目录下创建一个和表名相同名的.frm文件保存表的定义。
	使用show table status命令可以查询表的信息。
	Name(表名)、Engine(表的存储类型)、Row_format(行的格式)、Rows(表的行数)、Avg_row_length(平均每行包含的字节数)、Data_length(表数据的大小)、Max_data_length(索引的大小)、Data_free(已分配耽美有使用的空间)、Auto_increnment(下一个自增值)、Create_time(表的创建时间)、Update_time(表最后修改时间)、Collation(表的默认字符集和字符列排序规则)、CheckSum(如果启用，保存的是整个表的实时校验和)
	InnoDB存储引擎(官方手册中的InnoDB事务模型和锁详细描写其的微妙之处)
		因为某些oracle历史原因，目前使用的是InnoDB旧版本，在MYSQL5.1之后集成了InnoDB plugin，其在创建、删除、新增索引时效率增加
		InnoDB除了采用MVCC以外还引入了间隙锁(next-key locking)(record记录锁和gap间隙锁的组合使用)策略防止幻影行的插入。
		【TODO 间隙锁】
		InooDB的索引结构是基于聚簇索引建立的具备很高的性能，但其二级索引(非主键索引)中必须包含主键列，所以如果注解列很大的话，其它所有的索引都会很大。
	MyISAM存储引擎
		MyISAM作为早期官方默认的存储引擎导致早期很多人认为mysql是不支持事务的。
		对于近乎只读场景或者表比较小依然是可以使用的优秀存储引擎。其主要问题在于表锁问题，导致其长期处于locked状态
	其它存储引擎目前并未大规模使用，值得一提的是mysql支持第三方存储引擎
		XtraDB，其基于InnoDB的改进版本，对于BLOB的优化要优秀不少
		列存储引擎Infobright，有了解过列存储的自然明白其对于大数据量做聚合类处理的强大之处
第2章 mysql基准测试
第3章 服务器性能剖析
第4章 Scheam与数据类型优化
选择优化的数据了许
	基本原则
		更小的通常更好
		整形比字符串更好
		尽量避免null
	整形:TINYINT,SMALLINT,MEDIUMINT,INT,BIGINT，分别使用8，16，24，32，64位存储空间，其可以设置UNSIGNED表示不允许负值，虽然mysql可以为其指定宽度，但其实是没有意义的
	实数:DECIMAL、FLOAT、DOUBLE等,DECIMAL可以存储比BIGINT还打的整数。对于DECIMAL(18,9)表示小数点左边最大9，右边最大9
	字符串:varchar和char。前者可变，后者定长。需要注意的是varchar虽然可变,存储空间虽然不同但是临时表消耗的内存开销是不一样的
	大文本:BLOB和TEXT。如果对齐使用排序，务必使用order by sustring(colume, length)，其并不支持索引。如果没有这样使用name就会导致磁盘临时表，这是非常消性能的(explain 计划的extra会包含 using temporary。如果在排序中出现了文件排序则说明为重新构建排序，性能极差)
第5章 创建高性能的索引
第6章 查询性能优化
第7章 mysql高级特性
第8章 优化服务器设置
第9章 操作系统和硬件优化
第10章 复制
第11章 可扩展的mysql
第12章 可用性
第13章 云端的mysql
第14章 应用层优化
第15章 备份与恢复
第16章 用户工具